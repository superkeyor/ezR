% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/frame.R
\name{ez.recode}
\alias{ez.recode}
\alias{ez.recode2}
\title{recode}
\usage{
ez.recode(df, col, recodes)

ez.recode2(df, col, recodes)
}
\arguments{
\item{df}{data.frame to be recoded}

\item{col}{the name of var to be recoded, must be a string in quotes ""}

\item{recodes}{Definition of the recoding rules. See details}
}
\value{
returns a new df, old one does not change
}
\description{
Recodes one single according to a set of rules
\cr\cr ez.recode replaces the original var with recoded var;
\cr ez.recode2 saves orignal var as var_ori, and then recodes var
\cr see also \code{\link{ez.replace}}
\cr keep data type whenever possible, remove all attr of col (otherwise could be inconsistent)
}
\details{
recodes contains a set of recoding rules separated by ";". There are three different types of recoding rules:
\itemize{
 \item{}{The simplest codes one value to another. If we wish to recode 1 into 2, we could use the rule "1=2;".}
 \item{}{A range of values can be coded to a single value using "1:3=4;". This rule would code all values between 1 and 3 inclusive into 4. For factors, a value is between two levels if it is between them in the factor ordering. One sided ranges can be specified using the lo and hi key words (e.g."lo:3=0; 4:hi=1")}
 \item{}{Default conditions can be coded using "else." For example, if we wish to recode all values >=0 to 1 and all values <0 to missing, we could use ("0:hi=1; else=NA")}
}
\cr Works with characters/factors as well e.g., ('Gr',"'U1'='U';'U2'='U';'R1'='R';'R2'='R'")
\cr characters to number does not work directly e.g., ('Gr',"'U1'=2;'U2'=3")  --> 2, 3 are converted to "2", "3" (char of number)
\cr but number to character works directly, char->char, factor->factor
\cr for factors, no need to reset levels (auto reset)
\cr The conclusion is: numeric<->numeric without quote
\cr but if newval is quoted character, then numeric->char, char->char, factor->factor
\cr See the example section for more detail.
}
\note{
Please note following behaviours of the function:
      \itemize{
        \item the \code{"else"}-token should be the last argument in the \code{recodes}-string.
        \item the \code{"else"}-token is optional. if not specified, simply copy over else.
        \item if multiple ranges overlap, the latter one prevails. 1:3=1;3:5=2 (3->2 finally).
        \item hi=Hi=HI=max, lo=Lo=LI=min, :=thru=Thru=THRU (mimic SPSS recode syntax)  -> can replace = as well
        \item Variable label attributes (see, for instance, \code{\link{get_label}}) are preserved if exists, however, value label attributes are removed (makes sense, right)
        \item the \code{\link[sjmisc]{rec}} function in sjmisc does not work well with double numbers (eg, 3.59)
}
}
\examples{
data<-data.frame(a=rnorm(100),b=rnorm(100),male=rnorm(100)>0)
ez.recode(data, "a", "hi = 1")
ez.recode(data, "a", "lo:0 = 0;0:hi = 1;")
ez.recode(data, "b", "lo:0 = 0;0:hi = 1;")
ez.recode(data, "a", "lo:0 = 'low';0:hi = 1;")  
         #a was numeric type, now is character type 
         #note: for hi=1, the 1 is not even quoted
         #can be quoted hi='1', but it does not matter here
data <- ez.recode(data,"male", "1 = 'Male';FALSE = 'Female';else = NA;")
         #both 1 and TRUE = 'Male' work
         #the last semicolon; after NA is not necessary
         #male was initially a logic type, now is a character type

data=data.frame(a=c('r1','r2'))
ez.recode(data,'a','"r1"="3"')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","r2")
ez.recode(data,'a','"r1"=3')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","r2")
ez.recode(data,'a','"r1"=3;"r2"=4')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","4")
}
\author{
Jerry Zhu modified from Ian Fellows (pkg Deducer) adapted from code by John Fox (car)
}
\seealso{
\code{\link[tidyr]{gather}}, \code{\link[tidyr]{spread}}, \code{\link[tidyr]{separate}}, \code{\link[tidyr]{unite}}
\cr \code{\link[dplyr]{select}}, \code{\link[dplyr]{slice}}
\cr \code{\link[dplyr]{distinct}}, \code{\link[dplyr]{arrange}}
\cr \code{\link[dplyr]{summarise}}, \code{\link[dplyr]{count}}, \code{\link[dplyr]{mutate}}
\cr \code{\link[dplyr]{group_by}}, \code{\link[dplyr]{left_join}}, \code{\link[dplyr]{right_join}}, \code{\link[dplyr]{inner_join}}, \code{\link[dplyr]{full_join}}, \code{\link[dplyr]{semi_join}}, \code{\link[dplyr]{anti_join}}
\cr \code{\link[dplyr]{intersect}}, \code{\link[dplyr]{union}}, \code{\link[dplyr]{setdiff}}
\cr \code{\link[dplyr]{bind_rows}}, \code{\link[dplyr]{bind_cols}}

Other data.transformation.functions: \code{\link{ez.2char}},
  \code{\link{ez.2factor}}, \code{\link{ez.2label}},
  \code{\link{ez.2long}}, \code{\link{ez.2lower}},
  \code{\link{ez.2value}}, \code{\link{ez.2wide}},
  \code{\link{ez.compute}}, \code{\link{ez.del}},
  \code{\link{ez.label.get}}, \code{\link{ez.label.set}},
  \code{\link{ez.leftjoin}}, \code{\link{ez.move}},
  \code{\link{ez.newcol}}, \code{\link{ez.num}},
  \code{\link{ez.recols}}, \code{\link{ez.recol}},
  \code{\link{ez.rename}}, \code{\link{ez.replace}},
  \code{\link{ez.rncols}}, \code{\link{ez.rncol}},
  \code{\link{ez.select}}, \code{\link{ez.sort}},
  \code{\link{ez.split}}, \code{\link{ez.str}},
  \code{\link{ez.unique}}, \code{\link{ez.values.get}},
  \code{\link{ez.values.set}}
}


% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/frame.R
\name{ez.recode}
\alias{ez.recode}
\alias{ez.recode2}
\title{recode}
\usage{
ez.recode(df, col, recodes)

ez.recode2(df, col, recodes)
}
\arguments{
\item{df}{data.frame to be recoded}

\item{col}{the name of var to be recoded, must be a string in quotes ""}

\item{recodes}{Definition of the recoding rules. See details}
}
\value{
returns a new df, old one does not change
}
\description{
Recodes one single according to a set of rules. Recommends for numeric (single value or range change)
\cr\cr ez.recode replaces the original var with recoded var;
\cr ez.recode2 saves orignal var as var_ori, and then recodes var
\cr see also \code{\link{ez.replace}}, recommends for numeric (single value change), characters, factors
\cr keep data type whenever possible, remove value labels attr of col (otherwise could be inconsistent), but variable label is kept for numeric, character, factors etc.
}
\details{
recodes contains a set of recoding rules separated by ";". There are several different types of recoding rules:
\itemize{
 \item The simplest codes one value to another. If we wish to recode 1 into 2, we could use the rule "1=2;".
 \item A range of values can be coded to a single value using "1:3=4;". This rule would code all values between 1 and 3 inclusive into 4. For factors, a value is between two levels if it is between them in the factor ordering. One sided ranges can be specified using the lo and hi key words (e.g."lo:3=0; 4:hi=1"). hi=Hi=HI=max, lo=Lo=LI=min, :=thru=Thru=THRU (mimic SPSS recode syntax)  -> can replace = as well. if multiple ranges overlap, the latter one prevails. 1:3=1;3:5=2 (3->2 finally).
 \item Default conditions can be coded using "else." For example, if we wish to recode all values >=0 to 1 and all values <0 to missing, we could use ("0:hi=1; else=NA"). the \code{"else"}-token should be the last argument in the \code{recodes}-string.
  \item Variable label attributes (see, for instance, \code{\link{get_label}}) are preserved if exists, however, value label attributes are removed (makes sense, right)
  \item the \code{\link{sjmisc_rec}} function in sjmisc does not work well with double numbers (eg, 3.59)
}
\cr
\cr ====================================================================================
\cr recommends \code{\link{ez.replace}} to change characters, factors
\cr ====================================================================================
\cr Works with characters/factors as well e.g., ('Gr',"'U1'='U';'U2'='U';'R1'='R';'R2'='R'")
\cr characters to number does not work directly e.g., ('Gr',"'U1'=2;'U2'=3")  --> 2, 3 are converted to "2", "3" (char of number)
\cr but number to character works directly, char->char, factor->factor
\cr for factors, no need to reset levels (auto reset)
\cr The conclusion is: numeric<->numeric without quote
\cr but if newval is quoted character, then numeric->char, char->char, factor->factor
\cr See the example section for more detail.
}
\examples{
data<-data.frame(a=rnorm(100),b=rnorm(100),male=rnorm(100)>0)
ez.recode(data, "a", "hi = 1")
ez.recode(data, "a", "lo:0 = 0;0:hi = 1;")
ez.recode(data, "b", "lo:0 = 0;0:hi = 1;")
ez.recode(data, "a", "lo:0 = 'low';0:hi = 1;")
         #a was numeric type, now is character type
         #note: for hi=1, the 1 is not even quoted
         #can be quoted hi='1', but it does not matter here
data <- ez.recode(data,"male", "1 = 'Male';FALSE = 'Female';else = NA;")
         #both 1 and TRUE = 'Male' work
         #the last semicolon; after NA is not necessary
         #male was initially a logic type, now is a character type

data=data.frame(a=c('r1','r2'))
ez.recode(data,'a','"r1"="3"')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","r2")
ez.recode(data,'a','"r1"=3')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","r2")
ez.recode(data,'a','"r1"=3;"r2"=4')
         # a was factor wih level ("r1","r2"), now still a factor, with level ("3","4")
}
\seealso{
\code{\link[tidyr]{gather}}, \code{\link[tidyr]{spread}}, \code{\link[tidyr]{separate}}, \code{\link[tidyr]{unite}}
\cr \code{\link[dplyr]{select}}, \code{\link[dplyr]{slice}}
\cr \code{\link[dplyr]{distinct}}, \code{\link[dplyr]{arrange}}
\cr \code{\link[dplyr]{summarise}}, \code{\link[dplyr]{count}}, \code{\link[dplyr]{mutate}}
\cr \code{\link[dplyr]{group_by}}, \code{\link[dplyr]{left_join}}, \code{\link[dplyr]{right_join}}, \code{\link[dplyr]{inner_join}}, \code{\link[dplyr]{full_join}}, \code{\link[dplyr]{semi_join}}, \code{\link[dplyr]{anti_join}}
\cr \code{\link[dplyr]{intersect}}, \code{\link[dplyr]{union}}, \code{\link[dplyr]{setdiff}}
\cr \code{\link[dplyr]{bind_rows}}, \code{\link[dplyr]{bind_cols}}

Other data transformation functions: 
\code{\link{ez.2char}()},
\code{\link{ez.2factor}()},
\code{\link{ez.2label}()},
\code{\link{ez.2long}()},
\code{\link{ez.2lower}()},
\code{\link{ez.2value}()},
\code{\link{ez.2wide}()},
\code{\link{ez.compute}()},
\code{\link{ez.del}()},
\code{\link{ez.move}()},
\code{\link{ez.newcol}()},
\code{\link{ez.num}()},
\code{\link{ez.recols}()},
\code{\link{ez.recol}()},
\code{\link{ez.rename}()},
\code{\link{ez.replace}()},
\code{\link{ez.rncols}()},
\code{\link{ez.rncol}()},
\code{\link{ez.select}()},
\code{\link{ez.sort}()},
\code{\link{ez.split}()},
\code{\link{ez.str}()},
\code{\link{ez.unique}()},
\code{\link{left_join}()}
}
\author{
Jerry Zhu modified from Ian Fellows (pkg Deducer) adapted from code by John Fox (car)
}
\concept{data transformation functions}
